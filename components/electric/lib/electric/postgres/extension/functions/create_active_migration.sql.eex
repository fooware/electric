-- This function captures the "CREATE TABLE" statement for the table
-- that's being electrified and stores it in the @ddl_table, in order for it
-- to be sent over the logical replication stream to Electric and be consumed
-- by the MigrationConsumer process there.

CREATE OR REPLACE FUNCTION <%= @schema %>.capture_ddl(query text DEFAULT NULL) RETURNS int8 AS $function$
DECLARE
    _txid xid8;
    _txts timestamptz;
    _version text;
    _trid int8;
BEGIN
    SELECT v.txid, v.txts, v.version
        INTO _txid, _txts, _version
        FROM <%= @schema %>.current_migration_version() v;

    _trid := (SELECT <%= @schema %>.create_active_migration(_txid, _txts, _version, query));

    RETURN _trid;
END;
$function$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION <%= @schema %>.create_active_migration(
    _txid <%= @txid_type %>,
    _txts timestamptz,
    _version text,
    _query text DEFAULT NULL
) RETURNS int8 AS
$function$
DECLARE
    trid int8;
BEGIN
    IF _query IS NULL THEN
        _query := current_query();
    END IF;
    RAISE NOTICE 'capture migration: % => %', _version, _query;
    INSERT INTO <%= @ddl_table %> (txid, txts, version, query) VALUES
          (_txid, _txts, _version, _query)
        ON CONFLICT ON CONSTRAINT ddl_table_unique_migrations DO NOTHING
        RETURNING id INTO trid;
    RETURN trid;
END;
$function$
LANGUAGE PLPGSQL;
