CREATE OR REPLACE FUNCTION <%= @schema %>.ddlx_command_end_handler()
RETURNS EVENT_TRIGGER AS $function$
DECLARE
    _trid int8;
    _cmd record;
    _capture bool := false;
    _table_id int8;
BEGIN
    -- Usually, this would be a great place for `pg_trigger_depth()`, but for event triggers that's always 0.
    IF (current_setting('electric.is_in_event_trigger', true) = 'true') THEN RETURN; END IF;
    RAISE DEBUG 'command_end_handler:: start';

    FOR _cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
    LOOP
            -- don't capture create table events, those are inserted by the electrify call
        CASE
            WHEN _cmd.object_type = 'table' THEN
               _capture := _capture OR <%= @schema %>.__table_is_electrified(_cmd.classid, _cmd.objid);
            WHEN _cmd.object_type = 'table column' THEN
                IF <%= @schema %>.__table_is_electrified(_cmd.classid, _cmd.objid) THEN
                    RAISE EXCEPTION 'modifying column of electrified table %', _cmd.object_identity;
                END IF;
            WHEN _cmd.command_tag = 'CREATE INDEX' THEN
                _table_id := <%= @schema %>.__create_index_is_electrified(_cmd.classid, _cmd.objid);
                IF _table_id THEN
                    -- capture the index id into a special electrified_index table
                    -- so that we can check if it's electrified when it's being dropped
                    -- without this, by the time we get the cmd in the event trigger the
                    -- index has already been dropped and the lookups required no longer
                    -- exist
                    INSERT INTO <%= @electrified_index_table %> (id, table_id) VALUES (_cmd.objid, _table_id);
                    _capture := true;
                END IF;
            ELSE NULL;
        END CASE;
    END LOOP;

    IF _capture THEN
        _trid := (SELECT <%= @schema %>.capture_ddl());
        RAISE DEBUG 'create_active_migration = %', _trid;

        -- We're going to alter multiple tables here. We don't want to re-trigger this function.
        PERFORM set_config('<%= @schema %>.is_in_event_trigger', 'true', true);
        FOR _cmd IN (SELECT * FROM pg_event_trigger_ddl_commands())
        LOOP
            RAISE DEBUG '  Current statement touches a % in schema % with objid %', _cmd.object_type, _cmd.schema_name, _cmd.object_identity;
            IF _cmd.object_type = 'table' AND <%= @schema %>.__table_is_electrified(_cmd.classid, _cmd.objid) THEN
                -- Since we're performing these calls only against already-electrified tables, this can only be an "ALTER TABLE" statement
                -- which means we won't be creating new tables, which means we don't need to add them to publications
                PERFORM <%= @schema %>.ddlx_make_or_update_shadow_tables(_cmd.command_tag, _cmd.schema_name, _cmd.objid);
            END IF;
        END LOOP;
        PERFORM set_config('<%= @schema %>.is_in_event_trigger', '', true);
    END IF;

    RAISE DEBUG 'command_end_handler:: end';
END;
$function$ LANGUAGE PLPGSQL;
