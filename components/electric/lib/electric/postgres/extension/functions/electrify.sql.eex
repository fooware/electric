-- you can call electrify using one of these variants:
--
-- 1. `CALL electric.electrify('my_table')`
-- 2. `CALL electric.electrify('my_schema', 'my_table')`
-- 3. `CALL electric.electrify('my_schema.my_table')`
--
-- the first two formats also support special characters in the table/schema name:
--
-- 4. `CALL electric.electrify('My Schema', 'My Table')`

CREATE OR REPLACE PROCEDURE <%= @schema %>.electrify(
    name1 text,
    name2 text DEFAULT NULL
) AS $function$
DECLARE
    _schema name;
    _table text;
    _quoted_name text;
    _oid regclass;
    _create_sql text;
BEGIN
    SELECT
        table_name, schema_name, table_oid
    INTO
        _table, _schema, _oid
    FROM <%= @schema %>.__resolve_table_from_names(name1, name2);

    _quoted_name := format('%I.%I', _schema, _table);
    _oid := (SELECT _quoted_name::regclass);

    RAISE NOTICE 'Electrify table %', _quoted_name;

    IF NOT EXISTS (SELECT pc.oid FROM pg_class pc WHERE pc.oid = _oid AND pc.relkind = 'r') THEN
        RAISE EXCEPTION '% is not an ordinary table', _quoted_name;
    END IF;

    PERFORM <%= @schema %>.__validate_table_column_types(_quoted_name);
    PERFORM <%= @schema %>.__validate_table_column_defaults(_quoted_name);

    EXECUTE format('ALTER TABLE %I.%I REPLICA IDENTITY FULL;', _schema, _table);

    INSERT INTO <%= @electrified_tracking_table %> (schema_name, table_name, oid)
    VALUES (_schema, _table, _oid)
    ON CONFLICT ON CONSTRAINT unique_table_name
    DO NOTHING;

    -- insert the required ddl into the migrations table
    SELECT <%= @schema %>.ddlx_create(_oid) INTO _create_sql;

    RAISE DEBUG '%', _create_sql;

    PERFORM <%= @schema %>.capture_ddl(_create_sql);

    IF NOT EXISTS (
        SELECT pr.oid FROM pg_publication_rel pr
            INNER JOIN pg_publication pp ON pr.prpubid = pp.oid
            WHERE pp.pubname = '<%= @publication_name %>' AND pr.prrelid = _oid
        ) THEN
        EXECUTE format('<%= @publication_sql %>;', _schema, _table);

        -- We want to disable any possible hooks from `CREATE TABLE` statements
        PERFORM set_config('<%= @schema %>.is_in_event_trigger', 'true', true);
        PERFORM <%= @schema %>.ddlx_make_or_update_shadow_tables('CREATE TABLE', _schema, _oid);
        PERFORM set_config('<%= @schema %>.is_in_event_trigger', '', true);

        EXECUTE format('<%= @publication_sql %>;', '<%= @schema %>', ('shadow__' || _schema || '__' || _table)::name);
    ELSE
        RAISE EXCEPTION 'table %.% is already electrified', _schema, _table;
    END IF;
END;
$function$ LANGUAGE PLPGSQL;

--
-- Utility functions
--

CREATE OR REPLACE FUNCTION <%= @schema %>.__resolve_table_from_names(
    name1 text,
    name2 text,
    OUT schema_name name,
    OUT table_name name,
    OUT table_oid regclass
) AS $function$
DECLARE
    _ident text[];
BEGIN
    IF name1 IS NULL AND name2 IS NULL THEN
        RAISE EXCEPTION 'no valid table name given';
    ELSIF name2 IS NULL THEN
        -- handle table passed as 'schema.table'
        IF strpos(name1, '.') > 0 THEN
            _ident := parse_ident(name1);
            IF array_length(_ident, 1) = 1 THEN
                table_name := _ident[1];
                table_oid := (SELECT quote_ident(table_name)::regclass);
                schema_name := <%= @schema %>.__table_schema(table_oid);
            ELSIF array_length(_ident, 1) = 2 THEN
                schema_name := _ident[1];
                table_name := _ident[2];
            ELSE
                RAISE EXCEPTION 'invalid table name given %', name1;
            END IF;
        ELSE
            table_name := name1;
            table_oid := (SELECT quote_ident(table_name)::regclass);
            schema_name := <%= @schema %>.__table_schema(table_oid);
        END IF;
    ELSIF name1 IS NOT NULL AND name2 IS NOT NULL THEN
        table_name := name2;
        schema_name := name1;
    ELSE
        RAISE EXCEPTION 'no valid table name given';
    END IF;
END;
$function$ LANGUAGE PLPGSQL STABLE;

CREATE OR REPLACE FUNCTION <%= @schema %>.__table_schema(table_oid oid) RETURNS name AS $function$
DECLARE
   _schema name;
BEGIN
    SELECT pn.nspname INTO _schema
        FROM pg_class pc
        INNER JOIN pg_namespace pn ON pc.relnamespace = pn.oid
        WHERE pc.oid = table_oid;
    RETURN _schema;
END;
$function$ LANGUAGE PLPGSQL;
